\documentclass[12pt,a4paper]{article}

% Márgenes
\usepackage[
  left=3cm, right=3cm,
  top=3.2cm, bottom=3.2cm
]{geometry}

% Idioma y codificación
\usepackage[spanish, es-nodecimaldot]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Utilidades
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{setspace}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{float}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{times}
\usepackage{listings}

% Configuration
\sisetup{
    separate-uncertainty=true,
    output-decimal-marker={.}
}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=blue
}

% Commands for vectors (bold, non-italic) and scalars (italic)
\renewcommand{\vec}[1]{\mathbf{#1}}

% Regla fina para separador
\newcommand{\ThinRule}{\noindent\rule{\textwidth}{0.4pt}}

% Regla de notas al pie corta
\makeatletter
\renewcommand{\footnoterule}{%
  \kern-3pt
  \noindent\rule{5.5cm}{0.4pt}\par\kern 6pt
}
\makeatother

% Ajustes de párrafo
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.6em}
\renewcommand{\contentsname}{Índice}

% Configuración de listings
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

% Helper para incluir figuras solo si existen
\newcommand{\includegraphicsifexists}[2][]{%
  \IfFileExists{#2}{%
    \includegraphics[#1]{#2}%
  }{%
    \fbox{\parbox{0.9\linewidth}{\centering \textbf{Falta generar resultado.}\\
    Genere el archivo \texttt{#2} ejecutando los scripts correspondientes.}}%
  }%
}

\begin{document}

\begin{titlepage}
\centering

% --- Logo ITBA centrado ---
\vspace*{0.3cm}
\includegraphics[width=4.2cm]{assets/logo-itba.png}\par

% --- Regla separadora ---
\vspace{0.6cm}
\ThinRule

% --- Título ---
\vspace{0.9cm}
\begingroup
\fontsize{18}{19.2}\selectfont
\textbf{Análisis GTFS Vancouver}\par
\endgroup

\vspace{0.4cm}
{\large Trabajo Final}\par
\vspace{0.25cm}
{\large 73.82 - Bases de Datos Espaciales y de Movilidad}\par

% --- Autores ---
\vspace{1.1cm}
{\normalsize \textbf{Autores:}}\par
\vspace{0.25cm}
{\large \textbf{Tomas Camilo Gay Bare\textsuperscript{1}}}\par
\vspace{0.15cm}
{\large \textbf{Manuel E. Dithurbide\textsuperscript{2}}}\par

% --- Fecha ---
\vspace{1.4cm}
{\normalsize Diciembre 2025}\par

% --- Notas al pie ---
\vfill
\footnotetext[1]{tgaybare@itba.edu.ar}
\footnotetext[2]{mdithurbide@itba.edu.ar}

\end{titlepage}

\tableofcontents
\newpage

\section{Introducción}

Este proyecto analiza el sistema de transporte de Vancouver utilizando datos GTFS estáticos
y GTFS-Realtime de TransLink. Se implementa un pipeline reproducible sobre PostgreSQL con
extensiones PostGIS y MobilityDB, utilizando Python para análisis y visualización.
El pipeline permite caracterizar la red estática, comparar planificación vs.\ operación
y generar visualizaciones para identificar problemas de servicio.

\section{Metodología de replicación}

En esta sección se documenta paso a paso el pipeline completo, desde la instalación
hasta la generación de los resultados presentados en las secciones siguientes.

\subsection{Instalación de dependencias}

Situarse en la raíz del repositorio y ejecutar:

\begin{lstlisting}[language=bash]
pip install -r requirements.txt
pip install -r static_analysis/requirements.txt
pip install -r realtime_analysis/requirements.txt
npm install -g gtfs-via-postgres
\end{lstlisting}

Configurar la conexión a la base de datos exportando las variables de entorno:

\begin{lstlisting}[language=bash]
export PGHOST=localhost
export PGPORT=5432
export PGUSER=postgres
export PGPASSWORD=postgres
export PGDATABASE=gtfs
\end{lstlisting}

Para hacer estas variables persistentes, agregarlas al perfil del shell
(e.g., \texttt{\textasciitilde/.bashrc}, \texttt{\textasciitilde/.zshrc}).

\subsection{Requisitos de la base de datos}

Antes de ejecutar cualquier comando, asegurarse de que:
\begin{itemize}
  \item La base de datos \texttt{gtfs} existe y está corriendo.
  \item Las extensiones \texttt{PostGIS} y \texttt{MobilityDB} están instaladas y habilitadas.
  \item Las variables de entorno de conexión están exportadas (ver sección anterior).
\end{itemize}

Se puede verificar la conexión y las extensiones con:

\begin{lstlisting}[language=bash]
psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE \
  -c "SELECT PostGIS_version(), MobilityDB_version();"
\end{lstlisting}

\subsection{Flujo GTFS estático}

\subsubsection{Descarga y preprocesamiento}

Ejecutar el script de descarga y limpieza:

\begin{lstlisting}[language=bash]
bash static_analysis/data/download_data.sh
\end{lstlisting}

Este paso genera los archivos prunados en \texttt{static\_analysis/data/gtfs\_pruned/}.

\subsubsection{Importación de tablas GTFS}

Con la base de datos en marcha, importar las tablas:

\begin{lstlisting}[language=bash]
cd static_analysis/data/gtfs_pruned
gtfs-to-sql --require-dependencies -- *.txt \
  | psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE
\end{lstlisting}

\subsubsection{Creación de estructuras MobilityDB}

Desde la raíz del repositorio:

\begin{lstlisting}[language=bash]
cat static_analysis/data_loading/mobilitydb_import.sql \
  | psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE
\end{lstlisting}

Este script genera tablas como \texttt{scheduled\_trips\_mdb},
\texttt{route\_segments}, vistas agregadas y columnas geométricas.

\subsubsection{Carga de densidad poblacional (opcional)}

Para los análisis que combinan densidad poblacional y cobertura de transporte,
se utiliza un GeoJSON de áreas censales de Vancouver. El siguiente script
calcula la densidad (\texttt{pop}/\texttt{a}) e importa la capa
\texttt{population\_areas} en la base de datos:

\begin{lstlisting}[language=bash]
python static_analysis/data/download_population_data.py \
  --geo static_analysis/data/population/vancouver_geo.geojson
\end{lstlisting}

\subsubsection{Consultas y visualizaciones estáticas}

Las vistas materializadas y las gráficas de análisis se generan con un único
comando que orquesta las consultas SQL y los scripts de visualización:

\begin{lstlisting}[language=bash]
cd static_analysis/queries
python run_all_analyses.py
\end{lstlisting}

Este comando:
\begin{itemize}
  \item Ejecuta los archivos SQL en \texttt{static\_analysis/queries/sql/},
        creando vistas materializadas \texttt{qgis\_*} para visualización en QGIS
        (densidad de rutas, segmentos de velocidad, población vs.\ transporte, etc.).
  \item Ejecuta los scripts de \texttt{static\_analysis/queries/visualizations/},
        generando gráficos en formato PNG (histogramas, distribuciones por ruta,
        comparaciones de velocidad, métricas de proximidad a estadios, etc.).
\end{itemize}

Los resultados se guardan en \texttt{static\_analysis/queries/results/},
organizados por tipo de análisis. Las vistas \texttt{qgis\_*} pueden cargarse
directamente en QGIS para producir mapas más detallados.

\subsection{Flujo GTFS-Realtime}

\subsubsection{Configuración y tablas realtime}

Instalar dependencias adicionales y configurar la API de TransLink:

\begin{lstlisting}[language=bash]
pip install -r realtime_analysis/requirements.txt
export TRANSLINK_GTFSR_API_KEY="your-translink-api-key"
\end{lstlisting}

Crear las tablas necesarias para datos realtime:

\begin{lstlisting}[language=bash]
cat realtime_analysis/realtime_schema.sql \
  | psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE
\end{lstlisting}

\subsubsection{Ingesta de feeds GTFS-Realtime}

Ejecutar el proceso de ingesta durante un intervalo de tiempo:

\begin{lstlisting}[language=bash]
python -m realtime_analysis.ingest_realtime \
  --duration-minutes 20 \
  --poll-interval 30
\end{lstlisting}

Este comando consulta periódicamente los endpoints de posiciones y actualizaciones de viaje,
almacenando los mensajes en tablas \texttt{realtime\_*}.

\subsubsection{Construcción de trayectorias reales}

A partir de los puntos GPS se construyen trayectorias \emph{map-matched} sobre los
recorridos estáticos:

\begin{lstlisting}[language=bash]
python -m realtime_analysis.build_realtime_trajectories --hours 2
\end{lstlisting}

Las trayectorias resultantes se almacenan en \texttt{realtime\_trips\_mdb}.
Los puntos GPS crudos se deduplican y se ajustan (\emph{snap}) a las formas
programadas antes de insertarse en la tabla.

\subsubsection{Análisis puntual de un recorrido}

Para comparar detalladamente un viaje programado vs.\ su ejecución real:

\begin{lstlisting}[language=bash]
python -m realtime_analysis.analyze_realtime \
  --route-short-name 99
\end{lstlisting}

Los resultados se escriben en \texttt{realtime\_analysis/output/} como mapas HTML,
gráficos de tiempos y archivos CSV con métricas por segmento.

\subsubsection{Consultas y análisis agregados con GTFS-Realtime}

Las vistas materializadas y los análisis agregados sobre datos realtime se
generan de forma análoga al flujo estático, a través de un único script
orquestador:

\begin{lstlisting}[language=bash]
cd realtime_analysis/queries
python run_all_analyses.py
\end{lstlisting}

Este comando ejecuta los archivos SQL de \texttt{realtime\_analysis/queries/sql/},
creando vistas \texttt{realtime\_*} y \texttt{qgis\_realtime\_*}, y luego corre
los scripts de visualización para producir gráficos en PNG y resúmenes en CSV.

También es posible ejecutar cada análisis de forma individual:

\begin{lstlisting}[language=bash]
cd realtime_analysis/queries/visualizations
python speed_vs_schedule_analysis.py
python schedule_times_analysis.py
python delay_segments_analysis.py
python headway_analysis.py
\end{lstlisting}

Los resultados se almacenan en \texttt{realtime\_analysis/queries/results/},
organizados por tipo de análisis.

\section{Análisis de GTFS estático}

\subsection{Distribución de tipos de rutas}

La primera consulta caracteriza la composición de la red en términos de tipo de servicio
(\texttt{bus}, \texttt{subway}, \texttt{rail}, \texttt{ferry}, etc.), utilizando las
tablas GTFS \texttt{routes} y un CTE de mapeo de códigos:

\begin{lstlisting}[language=SQL]
WITH route_types(route_type, name) AS (
  SELECT '0', 'streetcar' UNION
  SELECT '1', 'subway'    UNION
  SELECT '2', 'rail'      UNION
  SELECT '3', 'bus'       UNION
  SELECT '4', 'ferry'     UNION
  SELECT '11', 'trolley'
),
route_groups AS (
  SELECT 
    route_type,
    COUNT(*) AS qty,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) AS perc
  FROM routes
  GROUP BY route_type
)
SELECT name, qty, perc 
FROM route_groups g JOIN route_types t ON g.route_type = t.route_type
ORDER BY perc DESC;
\end{lstlisting}

Esta consulta devuelve, para cada modo, la cantidad de rutas y su porcentaje sobre
el total. En la práctica, complementamos esta tabla con un mapa de la red completa
y un gráfico de distribución de viajes por ruta, mostrados en las
Figuras~\ref{fig:route-map} y~\ref{fig:route-trip-dist}.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/route_visualization/route_visualization_map.png}
  \caption{Mapa de la red de rutas de Vancouver a partir de GTFS estático.}
  \label{fig:route-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/route_visualization/route_trip_distribution.png}
  \caption{Distribución del número de viajes por ruta.}
  \label{fig:route-trip-dist}
\end{figure}

En el mapa se observa una red especialmente densa en el centro de Vancouver y en
los corredores troncales hacia el este y el sur. El histograma muestra que un
subconjunto reducido de rutas concentra un gran número de viajes diarios, mientras
que la mayoría opera con menor frecuencia, típicamente en zonas periféricas.

\subsection{Densidad de rutas por segmento}

Para estudiar la densidad de servicio sobre el espacio urbano se construye la vista
materializada \texttt{segment\_route\_density}, basada en la tabla
\texttt{route\_segments}:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS segment_route_density;
CREATE MATERIALIZED VIEW segment_route_density AS
SELECT
  stop1_id || stop2_id as segment_id,
  seg_geom,
  COUNT(DISTINCT route_id) AS num_routes
FROM route_segments
WHERE seg_geom IS NOT NULL
GROUP BY stop1_id, stop2_id, seg_geom;
\end{lstlisting}

El script \texttt{route\_density\_analysis.py} resume esta información y genera
un histograma de densidad (Figura~\ref{fig:route-density-hist}), mientras que
las vistas materializadas se utilizan para construir un mapa de densidad de
segmentos (Figura~\ref{fig:route-density-map}).

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/route_density/route_density_histogram.png}
  \caption{Histograma de cantidad de rutas por segmento.}
  \label{fig:route-density-hist}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/route_density/route_density_map.png}
  \caption{Mapa de densidad de rutas sobre la red de segmentos.}
  \label{fig:route-density-map}
\end{figure}

El histograma evidencia que la mayoría de segmentos tiene pocas rutas superpuestas,
mientras que un número reducido de corredores concentra un alto nivel de servicio.
En el mapa estos corredores de alta densidad aparecen como líneas más intensas
alrededor del centro y en ejes troncales, mientras que las zonas periféricas
muestran menor superposición de rutas.

\subsection{Duplicación de rutas}

La duplicación de recorridos se analiza mediante el cálculo de segmentos compartidos
entre pares de rutas. La siguiente consulta (fragmento) construye la vista
\texttt{route\_duplication}:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS route_duplication;
CREATE MATERIALIZED VIEW route_duplication AS
WITH route_segment_pairs AS (
  SELECT DISTINCT
    rs1.route_id AS route1,
    rs2.route_id AS route2,
    COUNT(DISTINCT CONCAT(rs1.stop1_id, rs1.stop2_id)) AS shared_segments
  FROM route_segments rs1
  JOIN route_segments rs2 
    ON rs1.stop1_id = rs2.stop1_id 
   AND rs1.stop2_id = rs2.stop2_id
   AND rs1.route_id < rs2.route_id
  WHERE rs1.seg_geom IS NOT NULL
    AND rs2.seg_geom IS NOT NULL
  GROUP BY rs1.route_id, rs2.route_id
  HAVING COUNT(DISTINCT CONCAT(rs1.stop1_id, rs1.stop2_id)) >= 5
)
SELECT *
FROM route_segment_pairs;
\end{lstlisting}

Sobre esta vista se calcula el porcentaje de solapamiento relativo para cada par
de rutas y se identifica el conjunto \texttt{highly\_duplicated\_routes}, es decir,
las rutas que comparten una fracción significativa de su recorrido con varias otras.

El script \texttt{route\_duplication\_analysis.py} produce la matriz de calor y
estadísticos que se presentan en la Figura~\ref{fig:route-duplication}.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/route_duplication/route_duplication_heatmap.png}
  \caption{Matriz de calor de solapamiento entre rutas
  (\texttt{route\_duplication\_heatmap.png}).}
  \label{fig:route-duplication}
\end{figure}

\subsection{Análisis de velocidades}

La velocidad promedio por segmento y por ruta se obtiene a partir de la duración
entre arribo a paradas consecutivas y la longitud del segmento geométrico:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS schedule_speeds;
CREATE MATERIALIZED VIEW schedule_speeds AS
SELECT 
  s.route_id || stop1_sequence || stop2_sequence as id,
  AVG(seg_length / EXTRACT(EPOCH FROM 
      (stop2_arrival_time - stop1_arrival_time)) * 3.6) AS speed_kmh,
  seg_geom
FROM route_segments s
WHERE stop2_arrival_time <> stop1_arrival_time
  AND seg_length > 0
GROUP BY s.route_id, stop1_sequence, stop2_sequence, seg_geom;
\end{lstlisting}

A partir de esta vista se derivan estadísticas agregadas por ruta
(\texttt{route\_speed\_stats}) y se identifican segmentos con velocidades
inusualmente altas (\texttt{high\_speed\_segments}). El script
\texttt{speed\_analysis.py} genera tanto mapas como gráficos resumiendo estas
métricas, mostrados en las Figuras~\ref{fig:speed-map} y~\ref{fig:speed-hist}.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/speed_analysis/speed_analysis_map.png}
  \caption{Mapa de velocidades promedio sobre la red de segmentos.}
  \label{fig:speed-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/speed_analysis/speed_distribution_histogram.png}
  \caption{Histograma de velocidades programadas por segmento.}
  \label{fig:speed-hist}
\end{figure}

En el mapa se aprecian claramente los tramos más rápidos (corredores de acceso
rápido y autopistas urbanas) frente a zonas de menor velocidad en el centro
y en arterias congestionadas. El histograma muestra una distribución concentrada
en torno a velocidades medias (20--40~km/h), con colas hacia valores muy bajos
que corresponden a tramos con fuerte fricción (semáforos, giros, áreas céntricas).

\subsection{Accesibilidad a estadios}

Se modelan estadios y arenas deportivas como puntos de interés dentro del área
de estudio. La tabla \texttt{football\_stadiums} se puebla con coordenadas
de BC Place, Rogers Arena y Pacific Coliseum, y se construyen métricas de acceso
en transporte público:

\begin{lstlisting}[language=SQL]
CREATE TABLE football_stadiums (
  id serial PRIMARY KEY,
  name text NOT NULL,
  team text,
  latitude float,
  longitude float,
  geom geometry(Point, 4326)
);

CREATE MATERIALIZED VIEW stadium_transit_access AS
SELECT 
  s.name AS stadium_name,
  s.team,
  (SELECT COUNT(*) 
   FROM stops st 
   WHERE ST_DistanceSphere(s.geom, st.stop_loc::geometry) <= 500) AS stops_500m,
  (SELECT COUNT(DISTINCT t.route_id)
   FROM stops st
   JOIN stop_times stt ON st.stop_id = stt.stop_id
   JOIN trips t ON stt.trip_id = t.trip_id
   WHERE ST_DistanceSphere(s.geom, st.stop_loc::geometry) <= 500) AS unique_routes_500m
FROM football_stadiums s;
\end{lstlisting}

El script \texttt{stadium\_proximity\_analysis.py} resume el número de viajes por
franja horaria y genera tanto mapas como gráficos de demanda hacia cada estadio.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/stadium_proximity/stadium_stops_and_routes.png}
  \caption{Mapa de estadios, paradas cercanas y rutas que los sirven.}
  \label{fig:stadium-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/stadium_proximity/stadium_trips_per_day.png}
  \caption{Viajes diarios que pasan cerca de cada estadio.}
  \label{fig:stadium-trips}
\end{figure}

En el mapa se aprecia que BC Place y Rogers Arena se encuentran en un nodo
concentrado de rutas y paradas, mientras que otros recintos presentan menor
densidad de servicio en su entorno inmediato. El gráfico de viajes diarios
muestra que los estadios céntricos reciben significativamente más oferta de
transporte que aquellos ubicados en zonas residenciales o periféricas.

\section{Análisis con GTFS-Realtime}

Los análisis sobre datos en tiempo real se basan en las trayectorias \emph{map-matched}
almacenadas en \texttt{realtime\_trips\_mdb}, las cuales se comparan con sus equivalentes
programados en \texttt{scheduled\_trips\_mdb}.

\subsection{Velocidad real vs.\ velocidad programada}

La comparación de velocidades se realiza mediante la vista materializada
\texttt{realtime\_speed\_comparison}, que calcula las velocidades programadas
y observadas para cada segmento:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_speed_comparison;
CREATE MATERIALIZED VIEW realtime_speed_comparison AS
WITH with_next_stop AS (
    SELECT
        d.trip_instance_id,
        d.trip_id,
        d.route_id,
        d.service_date,
        d.stop_sequence,
        d.stop_id,
        d.actual_arrival,
        LEAD(d.stop_sequence) OVER w AS next_stop_sequence,
        LEAD(d.stop_id) OVER w AS next_stop_id,
        LEAD(d.actual_arrival) OVER w AS next_actual_arrival
    FROM rt_trip_updates_deduped d
    WINDOW w AS (PARTITION BY d.trip_instance_id ORDER BY d.stop_sequence)
)
SELECT
    w.trip_instance_id,
    w.trip_id,
    r.route_short_name,
    w.route_id,
    rs.seg_length AS segment_length_m,
    EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) AS scheduled_seconds,
    EXTRACT(EPOCH FROM (w.next_actual_arrival - w.actual_arrival)) AS actual_seconds,
    (rs.seg_length / NULLIF(EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)), 0) * 3.6) AS scheduled_speed_kmh,
    (rs.seg_length / NULLIF(EXTRACT(EPOCH FROM (w.next_actual_arrival - w.actual_arrival)), 0) * 3.6) AS actual_speed_kmh
FROM with_next_stop w
JOIN route_segments rs
    ON rs.trip_id = w.trip_id
    AND rs.stop1_sequence = w.stop_sequence
LEFT JOIN routes r ON r.route_id = w.route_id
WHERE w.next_actual_arrival IS NOT NULL
  AND rs.seg_length > 10
  AND EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) > 0
  AND EXTRACT(EPOCH FROM (w.next_actual_arrival - w.actual_arrival)) > 0;
\end{lstlisting}

Los resultados de esta consulta se visualizan mediante un conjunto de gráficos
que comparan velocidades programadas vs.\ observadas. En la
Figura~\ref{fig:realtime-speed-scatter} se ilustra el diagrama de dispersión
para una corrida de análisis, donde cada punto representa un segmento entre
paradas consecutivas y se aprecia que muchos puntos quedan por debajo de la
línea de igualdad (velocidades reales menores a las programadas), sobre todo
en los tramos teóricamente más rápidos.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/speed_vs_schedule/speed_scatter.png}
  \caption{Comparación de velocidad programada vs.\ observada.}
  \label{fig:realtime-speed-scatter}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.9\textwidth]{%
    ../realtime_analysis/queries/results/speed_vs_schedule/speed_difference.png}
  \caption{Distribución de la diferencia de velocidad (real $-$ programada).}
  \label{fig:realtime-speed-diff}
\end{figure}

El histograma de diferencias (Figura~\ref{fig:realtime-speed-diff}) muestra una
distribución aproximadamente unimodal, centrada levemente por encima de cero:
en promedio los buses circulan unos pocos km/h más rápido que lo previsto,
pero con colas hacia valores positivos que evidencian episodios de
sobreejecución y hacia valores negativos asociadas a tramos muy congestionados.

\subsection{Desempeño de horarios (schedule times)}

La comparación de horarios programados vs.\ observados se realiza mediante la vista
materializada \texttt{realtime\_schedule\_times}:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_schedule_times;
CREATE MATERIALIZED VIEW realtime_schedule_times AS
SELECT
    d.trip_instance_id,
    d.trip_id,
    r.route_short_name,
    r.route_long_name,
    d.route_id,
    d.service_date,
    d.stop_sequence,
    d.stop_id,
    s.stop_name,
    ts.arrival_time AS scheduled_arrival_interval,
    d.actual_arrival,
    d.actual_departure,
    d.arrival_delay_seconds,
    d.departure_delay_seconds,
    d.arrival_delay_seconds / 60.0 AS delay_minutes,
    EXTRACT(hour FROM d.actual_arrival) AS hour_of_day,
    EXTRACT(dow FROM d.actual_arrival) AS day_of_week,
    CASE 
        WHEN EXTRACT(dow FROM d.actual_arrival) IN (0, 6) THEN 'Weekend'
        ELSE 'Weekday'
    END AS day_type
FROM rt_trip_updates_deduped d
JOIN routes r ON r.route_id = d.route_id
LEFT JOIN stops s ON s.stop_id = d.stop_id
LEFT JOIN transit_stops ts 
    ON ts.trip_id = d.trip_id 
    AND ts.stop_sequence = d.stop_sequence
WHERE d.arrival_delay_seconds IS NOT NULL;
\end{lstlisting}

Sobre esta vista se construyen distintos gráficos que resumen el comportamiento
de las demoras (histogramas, boxplots por hora, promedios por ruta, etc.).
En la Figura~\ref{fig:realtime-delay-hist} se muestra el histograma de demoras
generado para una corrida específica, donde se observa una cola hacia valores
positivos que indica predominio de demoras por encima del horario programado.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/schedule_times/delay_histogram.png}
  \caption{Distribución de demoras respecto al horario programado.}
  \label{fig:realtime-delay-hist}
\end{figure}

\subsection{Segmentos de demora y patrones de congestión}

El análisis de demoras por segmento se basa en la vista materializada
\texttt{realtime\_delay\_analysis}:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_delay_analysis;
CREATE MATERIALIZED VIEW realtime_delay_analysis AS
WITH with_next AS (
    SELECT
        d.trip_instance_id,
        d.trip_id,
        d.route_id,
        d.service_date,
        d.stop_sequence AS from_seq,
        d.stop_id AS from_stop_id,
        d.actual_arrival AS from_arrival,
        d.arrival_delay_seconds AS from_delay,
        LEAD(d.stop_sequence) OVER w AS to_seq,
        LEAD(d.stop_id) OVER w AS to_stop_id,
        LEAD(d.actual_arrival) OVER w AS to_arrival,
        LEAD(d.arrival_delay_seconds) OVER w AS to_delay
    FROM rt_trip_updates_deduped d
    WINDOW w AS (PARTITION BY d.trip_instance_id ORDER BY d.stop_sequence)
)
SELECT
    w.trip_instance_id,
    w.trip_id,
    r.route_short_name,
    w.route_id,
    w.from_seq,
    w.to_seq,
    rs.seg_length AS segment_length_m,
    rs.seg_geom,
    EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) AS scheduled_seconds,
    EXTRACT(EPOCH FROM (w.to_arrival - w.from_arrival)) AS actual_seconds,
    (w.to_delay - w.from_delay) AS segment_delay_change,
    (EXTRACT(EPOCH FROM (w.to_arrival - w.from_arrival)) - 
     EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time))) / 60.0 AS segment_delay_minutes,
    EXTRACT(hour FROM w.from_arrival) AS hour_of_day,
    EXTRACT(dow FROM w.from_arrival) AS day_of_week,
    CASE 
        WHEN EXTRACT(dow FROM w.from_arrival) IN (0, 6) THEN 'Weekend'
        ELSE 'Weekday'
    END AS day_type,
    CASE
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 7 AND 9 THEN 'Morning Rush'
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 16 AND 18 THEN 'Evening Rush'
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 9 AND 16 THEN 'Midday'
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 18 AND 22 THEN 'Evening'
        ELSE 'Night'
    END AS time_period
FROM with_next w
JOIN route_segments rs 
    ON rs.trip_id = w.trip_id 
    AND rs.stop1_sequence = w.from_seq
LEFT JOIN routes r ON r.route_id = w.route_id
WHERE w.to_arrival IS NOT NULL
  AND rs.seg_length > 10
  AND EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) > 0
  AND EXTRACT(EPOCH FROM (w.to_arrival - w.from_arrival)) > 0;
\end{lstlisting}

El análisis agrega esta información en distintos gráficos (por hora, por tipo
de día, por severidad de la demora, etc.). En particular, la
Figura~\ref{fig:realtime-worst-segments} resume gráficamente los segmentos
más afectados en términos de demora promedio.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/delay_segments/worst_segments.png}
  \caption{Segmentos con mayores demoras promedio.}
  \label{fig:realtime-worst-segments}
\end{figure}

\subsection{Regularidad de headways y \emph{bus bunching}}

El análisis de headways se basa en la vista materializada
\texttt{realtime\_headway\_stats}, que calcula los intervalos entre vehículos
consecutivos:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_headway_stats;
CREATE MATERIALIZED VIEW realtime_headway_stats AS
WITH stop_arrivals AS (
    SELECT
        rtu.route_id,
        r.route_short_name,
        rtu.stop_id,
        s.stop_name,
        rtu.trip_instance_id,
        rtu.trip_id,
        rtu.arrival_time,
        EXTRACT(hour FROM rtu.arrival_time) AS hour_of_day,
        EXTRACT(dow FROM rtu.arrival_time) AS day_of_week,
        CASE 
            WHEN EXTRACT(dow FROM rtu.arrival_time) IN (0, 6) THEN 'Weekend'
            ELSE 'Weekday'
        END AS day_type,
        CASE
            WHEN EXTRACT(hour FROM rtu.arrival_time) BETWEEN 7 AND 9 THEN 'Morning Rush'
            WHEN EXTRACT(hour FROM rtu.arrival_time) BETWEEN 16 AND 18 THEN 'Evening Rush'
            WHEN EXTRACT(hour FROM rtu.arrival_time) BETWEEN 9 AND 16 THEN 'Midday'
            WHEN EXTRACT(hour FROM rtu.arrival_time) BETWEEN 18 AND 22 THEN 'Evening'
            ELSE 'Night'
        END AS time_period
    FROM rt_trip_updates rtu
    JOIN routes r ON r.route_id = rtu.route_id
    LEFT JOIN stops s ON s.stop_id = rtu.stop_id
    WHERE rtu.arrival_time IS NOT NULL
      AND rtu.stop_id IS NOT NULL
),
with_prev AS (
    SELECT
        *,
        LAG(arrival_time) OVER (
            PARTITION BY route_id, stop_id
            ORDER BY arrival_time
        ) AS prev_arrival,
        LAG(trip_instance_id) OVER (
            PARTITION BY route_id, stop_id
            ORDER BY arrival_time
        ) AS prev_trip_instance_id
    FROM stop_arrivals
)
SELECT
    route_id,
    route_short_name,
    stop_id,
    stop_name,
    trip_instance_id,
    prev_trip_instance_id,
    arrival_time,
    prev_arrival,
    EXTRACT(EPOCH FROM (arrival_time - prev_arrival)) / 60.0 AS headway_minutes,
    hour_of_day,
    day_of_week,
    day_type,
    time_period
FROM with_prev
WHERE prev_arrival IS NOT NULL
  AND trip_instance_id != prev_trip_instance_id
  AND EXTRACT(EPOCH FROM (arrival_time - prev_arrival)) > 0
  AND EXTRACT(EPOCH FROM (arrival_time - prev_arrival)) < 7200;
\end{lstlisting}

El script \texttt{headway\_analysis.py} utiliza esta vista para categorizar
los headways como:

\begin{itemize}
  \item \textbf{Bunched} (\(<3\) minutos): vehículos demasiado próximos.
  \item \textbf{Good} (3--10 minutos): intervalo deseable en rutas frecuentes.
  \item \textbf{Acceptable} (10--20 minutos): servicio menos frecuente pero razonable.
  \item \textbf{Gap} (\(>20\) minutos): esperas prolongadas.
\end{itemize}

La Figura~\ref{fig:realtime-headway-dist} muestra la distribución de headways
obtenida a partir de los registros realtime.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/headway_analysis/headway_distribution.png}
  \caption{Distribución de headways entre vehículos.}
  \label{fig:realtime-headway-dist}
\end{figure}

\section{Discusión y trabajo futuro}

El pipeline desarrollado permite integrar datos GTFS estáticos y GTFS-Realtime en
una única base de datos espacial y reproducir de forma sistemática una serie de
consultas y visualizaciones sobre la red de transporte de Vancouver.
La separación clara entre scripts de ingesta, consultas SQL y scripts de
visualización facilita la extensión del análisis a nuevas ciudades o a períodos
de tiempo adicionales.

Como trabajo futuro se identifican varias líneas de avance: incorporar análisis
de robustez ante fallas (por ejemplo, cierres de estaciones), extender las métricas
de confiabilidad al nivel de pasajero (tiempos puerta a puerta) e integrar datos
de demanda (conteos o validaciones) para estudiar la relación entre oferta,
congestión y ocupación vehicular.

\end{document}


