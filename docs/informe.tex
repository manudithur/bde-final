\documentclass[12pt,a4paper]{article}

% Márgenes
\usepackage[
  left=3cm, right=3cm,
  top=3.2cm, bottom=3.2cm
]{geometry}

% Idioma y codificación
\usepackage[spanish, es-nodecimaldot]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Utilidades
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{setspace}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{float}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{times}
\usepackage{listings}

% Configuration
\sisetup{
    separate-uncertainty=true,
    output-decimal-marker={.}
}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=blue
}

% Commands for vectors (bold, non-italic) and scalars (italic)
\renewcommand{\vec}[1]{\mathbf{#1}}

% Regla fina para separador
\newcommand{\ThinRule}{\noindent\rule{\textwidth}{0.4pt}}

% Regla de notas al pie corta
\makeatletter
\renewcommand{\footnoterule}{%
  \kern-3pt
  \noindent\rule{5.5cm}{0.4pt}\par\kern 6pt
}
\makeatother

% Ajustes de párrafo
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.6em}
\renewcommand{\contentsname}{Índice}

% Configuración de listings
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

% Helper para incluir figuras solo si existen
\newcommand{\includegraphicsifexists}[2][]{%
  \IfFileExists{#2}{%
    \includegraphics[#1]{#2}%
  }{%
    \fbox{\parbox{0.9\linewidth}{\centering \textbf{Falta generar resultado.}\\
    Genere el archivo \texttt{#2} ejecutando los scripts correspondientes.}}%
  }%
}

\begin{document}

\begin{titlepage}
\centering

% --- Logo ITBA centrado ---
\vspace*{0.3cm}
\includegraphics[width=4.2cm]{assets/logo-itba.png}\par

% --- Regla separadora ---
\vspace{0.6cm}
\ThinRule

% --- Título ---
\vspace{0.9cm}
\begingroup
\fontsize{18}{19.2}\selectfont
\textbf{Análisis GTFS Vancouver}\par
\endgroup

\vspace{0.4cm}
{\large Trabajo Final}\par
\vspace{0.25cm}
{\large 73.82 - Bases de Datos Espaciales y de Movilidad}\par

% --- Autores ---
\vspace{1.1cm}
{\normalsize \textbf{Autores:}}\par
\vspace{0.25cm}
{\large \textbf{Tomas Camilo Gay Bare\textsuperscript{1}}}\par
\vspace{0.15cm}
{\large \textbf{Manuel E. Dithurbide\textsuperscript{2}}}\par

% --- Fecha ---
\vspace{1.4cm}
{\normalsize Diciembre 2025}\par

% --- Notas al pie ---
\vfill
\footnotetext[1]{tgaybare@itba.edu.ar}
\footnotetext[2]{mdithurbide@itba.edu.ar}

\end{titlepage}

\tableofcontents
\newpage

\section{Introducción}

Este proyecto analiza el sistema de transporte de Vancouver utilizando datos GTFS estáticos
y GTFS-Realtime de TransLink. Se implementa un pipeline reproducible sobre PostgreSQL con
extensiones PostGIS y MobilityDB, utilizando Python para análisis y visualización.
El pipeline permite caracterizar la red estática, comparar planificación vs.\ operación
y generar visualizaciones para identificar problemas de servicio.

\section{Metodología de replicación}

En esta sección se documenta paso a paso el pipeline completo, desde la instalación
hasta la generación de los resultados presentados en las secciones siguientes.

\subsection{Instalación de dependencias}

Situarse en la raíz del repositorio y ejecutar:

\begin{lstlisting}[language=bash]
pip install -r requirements.txt
pip install -r static_analysis/requirements.txt
pip install -r realtime_analysis/requirements.txt
npm install -g gtfs-via-postgres
\end{lstlisting}

Configurar la conexión a la base de datos exportando las variables de entorno:

\begin{lstlisting}[language=bash]
export PGHOST=localhost
export PGPORT=5432
export PGUSER=postgres
export PGPASSWORD=postgres
export PGDATABASE=gtfs
\end{lstlisting}

Para hacer estas variables persistentes, agregarlas al perfil del shell
(e.g., \texttt{\textasciitilde/.bashrc}, \texttt{\textasciitilde/.zshrc}).

\subsection{Requisitos de la base de datos}

Antes de ejecutar cualquier comando, asegurarse de que:
\begin{itemize}
  \item La base de datos \texttt{gtfs} existe y está corriendo.
  \item Las extensiones \texttt{PostGIS} y \texttt{MobilityDB} están instaladas y habilitadas.
  \item Las variables de entorno de conexión están exportadas (ver sección anterior).
\end{itemize}

Se puede verificar la conexión y las extensiones con:

\begin{lstlisting}[language=bash]
psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE \
  -c "SELECT PostGIS_version(), MobilityDB_version();"
\end{lstlisting}

\subsection{Flujo GTFS estático}

\subsubsection{Descarga y preprocesamiento}

Ejecutar el script de descarga y limpieza:

\begin{lstlisting}[language=bash]
bash static_analysis/data/download_data.sh
\end{lstlisting}

Este paso genera los archivos prunados en \texttt{static\_analysis/data/gtfs\_pruned/}.

\subsubsection{Importación de tablas GTFS}

Con la base de datos en marcha, importar las tablas:

\begin{lstlisting}[language=bash]
cd static_analysis/data/gtfs_pruned
gtfs-to-sql --require-dependencies -- *.txt \
  | psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE
\end{lstlisting}

\subsubsection{Creación de estructuras MobilityDB}

Desde la raíz del repositorio:

\begin{lstlisting}[language=bash]
cat static_analysis/data_loading/mobilitydb_import.sql \
  | psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE
\end{lstlisting}

Este script genera tablas como \texttt{scheduled\_trips\_mdb},
\texttt{route\_segments}, vistas agregadas y columnas geométricas.

\subsubsection{Carga de densidad poblacional (opcional)}

Para los análisis que combinan densidad poblacional y cobertura de transporte,
se utiliza un GeoJSON de áreas censales de Vancouver. El siguiente script
calcula la densidad (\texttt{pop}/\texttt{a}) e importa la capa
\texttt{population\_areas} en la base de datos:

\begin{lstlisting}[language=bash]
python static_analysis/data/download_population_data.py \
  --geo static_analysis/data/population/vancouver_geo.geojson
\end{lstlisting}

\subsubsection{Consultas y visualizaciones estáticas}

Las vistas materializadas y las gráficas de análisis se generan con un único
comando que orquesta las consultas SQL y los scripts de visualización:

\begin{lstlisting}[language=bash]
cd static_analysis/queries
python run_all_analyses.py
\end{lstlisting}

Este comando:
\begin{itemize}
  \item Ejecuta los archivos SQL en \texttt{static\_analysis/queries/sql/},
        creando vistas materializadas \texttt{qgis\_*} para visualización en QGIS
        (densidad de rutas, segmentos de velocidad, población vs.\ transporte, etc.).
  \item Ejecuta los scripts de \texttt{static\_analysis/queries/visualizations/},
        generando gráficos en formato PNG (histogramas, distribuciones por ruta,
        comparaciones de velocidad, métricas de proximidad a estadios, etc.).
\end{itemize}

Los resultados se guardan en \texttt{static\_analysis/queries/results/},
organizados por tipo de análisis. Las vistas \texttt{qgis\_*} pueden cargarse
directamente en QGIS para producir mapas más detallados.

\subsection{Flujo GTFS-Realtime}

\subsubsection{Configuración y tablas realtime}

Instalar dependencias adicionales y configurar la API de TransLink:

\begin{lstlisting}[language=bash]
pip install -r realtime_analysis/requirements.txt
export TRANSLINK_GTFSR_API_KEY="your-translink-api-key"
\end{lstlisting}

Crear las tablas necesarias para datos realtime:

\begin{lstlisting}[language=bash]
cat realtime_analysis/realtime_schema.sql \
  | psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE
\end{lstlisting}

\subsubsection{Ingesta de feeds GTFS-Realtime}

Ejecutar el proceso de ingesta durante un intervalo de tiempo:

\begin{lstlisting}[language=bash]
python -m realtime_analysis.data.ingest_realtime \
  --duration-minutes 20 \
  --poll-interval 30
\end{lstlisting}

Este comando consulta periódicamente los endpoints de posiciones y actualizaciones de viaje,
almacenando los mensajes en tablas \texttt{realtime\_*}.

\subsubsection{Construcción de trayectorias reales}

A partir de los puntos GPS se construyen trayectorias \emph{map-matched} sobre los
recorridos estáticos:

\begin{lstlisting}[language=bash]
python -m realtime_analysis.build_realtime_trajectories --hours 2
\end{lstlisting}

Las trayectorias resultantes se almacenan en \texttt{realtime\_trips\_mdb}.
Los puntos GPS crudos se deduplican y se ajustan (\emph{snap}) a las formas
programadas antes de insertarse en la tabla.

\subsubsection{Análisis puntual de un recorrido}

Para comparar detalladamente un viaje programado vs.\ su ejecución real:

\begin{lstlisting}[language=bash]
python -m realtime_analysis.queries.analysis.analyze_realtime \
  --route-short-name 99
\end{lstlisting}

Los resultados se escriben en \texttt{realtime\_analysis/output/} como mapas HTML,
gráficos de tiempos y archivos CSV con métricas por segmento.

\subsubsection{Consultas y análisis agregados con GTFS-Realtime}

Las vistas materializadas y los análisis agregados sobre datos realtime se
generan de forma análoga al flujo estático, a través de un único script
orquestador:

\begin{lstlisting}[language=bash]
cd realtime_analysis/queries
python run_all_analyses.py
\end{lstlisting}

Este comando ejecuta los archivos SQL de \texttt{realtime\_analysis/queries/sql/},
creando vistas \texttt{realtime\_*} y \texttt{qgis\_realtime\_*}, y luego corre
los scripts de visualización para producir gráficos en PNG y resúmenes en CSV.

También es posible ejecutar cada análisis de forma individual:

\begin{lstlisting}[language=bash]
cd realtime_analysis/queries/visualizations
python speed_vs_schedule_analysis.py
python schedule_times_analysis.py
python delay_segments_analysis.py
python headway_analysis.py
\end{lstlisting}

Los resultados se almacenan en \texttt{realtime\_analysis/queries/results/},
organizados por tipo de análisis.

\section{Análisis de GTFS estático}

\subsection{Composición y alcance de la red}

La primera consulta caracteriza la composición de la red en términos de tipo de servicio
(\texttt{bus}, \texttt{subway}, \texttt{rail}, \texttt{ferry}, etc.), utilizando las
tablas GTFS \texttt{routes} y un CTE de mapeo de códigos:

\begin{lstlisting}[language=SQL]
WITH route_types(route_type, name) AS (
  SELECT '0', 'streetcar' UNION
  SELECT '1', 'subway'    UNION
  SELECT '2', 'rail'      UNION
  SELECT '3', 'bus'       UNION
  SELECT '4', 'ferry'     UNION
  SELECT '11', 'trolley'
),
route_groups AS (
  SELECT 
    route_type,
    COUNT(*) AS qty,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) AS perc
  FROM routes
  GROUP BY route_type
)
SELECT name, qty, perc 
FROM route_groups g JOIN route_types t ON g.route_type = t.route_type
ORDER BY perc DESC;
\end{lstlisting}

Esta consulta devuelve, para cada modo, la cantidad de rutas y su porcentaje sobre
el total. A partir de la vista materializada \texttt{qgis\_route\_visualization},
QGIS genera un mapa de la red completa (Figura~\ref{fig:route-map}), mientras que
el script \texttt{route\_visualization.py} construye gráficos de oferta por ruta
que complementan la lectura visual de la red.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/route_visualization/route_visualization_map.png}
  \caption{Mapa de la red de rutas de Vancouver a partir de GTFS estático.}
  \label{fig:route-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/route_visualization/route_trip_statistics.png}
  \caption{Rutas de colectivo ordenadas por cantidad de viajes diarios.}
  \label{fig:route-trip-stats}
\end{figure}

El mapa evidencia una red especialmente densa en el centro de Vancouver y en
los corredores troncales hacia el este y el sur. El gráfico de barras muestra
que un subconjunto reducido de rutas concentra gran parte de los viajes diarios,
mientras que la mayoría opera con menor frecuencia, típicamente en zonas periféricas.

\subsection{Densidad de rutas por segmento}

Para estudiar la superposición de recorridos sobre el espacio urbano se construye 
una vista materializada de densidad de rutas por segmento (\texttt{segment\_route\_density})
basada en \texttt{route\_segments}. Un fragmento simplificado de la definición es:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS segment_route_density;
CREATE MATERIALIZED VIEW segment_route_density AS
SELECT
  stop1_id || stop2_id AS segment_id,
  seg_geom,
  COUNT(DISTINCT route_id) AS num_routes
FROM route_segments
WHERE seg_geom IS NOT NULL
GROUP BY stop1_id, stop2_id, seg_geom;
\end{lstlisting}

En la implementación final esta lógica se encapsula en las consultas de
\texttt{static\_analysis/queries/sql/} y se materializa junto con el resto de
vistas al ejecutar \texttt{static\_analysis/queries/run\_all\_analyses.py}.
El script \texttt{route\_density\_analysis.py}
resume esta información y genera un histograma de densidad
(Figura~\ref{fig:route-density-hist}), mientras que la vista se utiliza como capa
en QGIS para construir el mapa de la Figura~\ref{fig:route-density-map}.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/route_density/route_density_histogram.png}
  \caption{Histograma de cantidad de rutas por segmento.}
  \label{fig:route-density-hist}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/route_density/route_density_map.png}
  \caption{Mapa de densidad de rutas sobre la red de segmentos
  (verde = 1--2 rutas; rojo = 3 o más rutas por segmento).}
  \label{fig:route-density-map}
\end{figure}

El histograma evidencia que la mayoría de segmentos tiene pocas rutas superpuestas,
mientras que un número reducido de corredores concentra un alto nivel de servicio.
En el mapa estos corredores de alta densidad aparecen en rojo alrededor del centro
de la ciudad y en ejes troncales, mientras que las zonas periféricas se observan
principalmente en verde, con menor superposición de recorridos.

\subsection{Velocidades programadas por segmento}

La velocidad promedio por segmento y por ruta se obtiene combinando \texttt{route\_segments}
con los horarios de llegada previstos, y se materializa en una vista de segmentos
con velocidad programada. Un esquema básico de cálculo de velocidades a partir de
los horarios es:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS schedule_speeds;
CREATE MATERIALIZED VIEW schedule_speeds AS
SELECT 
  s.route_id || stop1_sequence || stop2_sequence AS id,
  AVG(seg_length / EXTRACT(EPOCH FROM 
      (stop2_arrival_time - stop1_arrival_time)) * 3.6) AS speed_kmh,
  seg_geom
FROM route_segments s
WHERE stop2_arrival_time <> stop1_arrival_time
  AND seg_length > 0
GROUP BY s.route_id, stop1_sequence, stop2_sequence, seg_geom;
\end{lstlisting}

Sobre esta base se construye la vista \texttt{qgis\_speed\_segments}, que agrega
estadísticas por ruta y filtra los segmentos inválidos. A partir de esta vista:

\begin{itemize}
  \item QGIS genera mapas de velocidad promedio sobre la red
  (Figuras~\ref{fig:speed-map} y~\ref{fig:speed-map-slow}),
  \item el script \texttt{speed\_analysis.py} construye histogramas y gráficos
        agregados por ruta y modo (Figura~\ref{fig:speed-hist}).
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/speed_analysis/speed_analysis_map.png}
  \caption{Mapa de velocidades programadas sobre la red de segmentos
  (3.5--19~km/h = verde punteado; 19--23~km/h = verde; 23--30~km/h = amarillo;
  $>$30~km/h = rojo).}
  \label{fig:speed-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/speed_analysis/speed_analysis_map_slow_zone.png}
  \caption{Detalle de zonas particularmente lentas en la red de segmentos.}
  \label{fig:speed-map-slow}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/speed_analysis/speed_distribution_histogram.png}
  \caption{Histograma de velocidades programadas por segmento.}
  \label{fig:speed-hist}
\end{figure}

Los mapas permiten localizar rápidamente los corredores con mayores velocidades
(en rojo y amarillo) frente a zonas más lentas (verde punteado), asociadas
generalmente a áreas céntricas o con alta fricción. El histograma muestra una
distribución concentrada en torno a velocidades medias, con colas hacia valores
muy bajos que corresponden a tramos fuertemente congestionados.

\subsection{Densidad poblacional y cobertura de transporte}

Para relacionar la oferta de transporte con la demanda potencial se incorporan
áreas censales de Vancouver con población y superficie. A partir de este insumo
se construye una capa de densidad poblacional y una superposición con la red de
transporte utilizando las vistas \texttt{population\_density} y
\texttt{qgis\_population\_transit\_overlay}.

Un esquema simplificado de la superposición entre densidad y recorridos es:

\begin{lstlisting}[language=SQL]
CREATE MATERIALIZED VIEW qgis_population_transit_overlay AS
WITH population_areas AS (
  SELECT
    id,
    geom,
    population_density,
    CAST(pop AS double precision) AS population,
    CAST(a AS double precision) AS area_km2
  FROM population_density
  WHERE geom IS NOT NULL
    AND population_density IS NOT NULL
),
bus_route_segments AS (
  SELECT DISTINCT
    rs.stop1_id || rs.stop2_id AS segment_id,
    rs.seg_geom
  FROM route_segments rs
  JOIN routes r ON rs.route_id = r.route_id
  WHERE r.route_type = '3'
    AND rs.seg_geom IS NOT NULL
)
SELECT 
  pa.id,
  pa.population_density,
  COUNT(DISTINCT brs.segment_id) AS num_segments,
  COALESCE(SUM(ST_Length(
      ST_Intersection(pa.geom, brs.seg_geom)::geography)) / 1000, 0) AS route_length_km,
  pa.area_km2,
  route_length_km / NULLIF(pa.area_km2, 0) AS route_density_km_per_km2,
  pa.geom
FROM population_areas pa
LEFT JOIN bus_route_segments brs 
  ON ST_Intersects(pa.geom, brs.seg_geom)
GROUP BY pa.id, pa.population_density, pa.geom, pa.area_km2;
\end{lstlisting}

Estas consultas se ejecutan automáticamente al correr
\texttt{static\_analysis/queries/run\_all\_analyses.py}, que primero crea las
vistas materializadas y luego genera los gráficos.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/population_density/pupulation_map.png}
  \caption{Mapa de densidad de población por área censal.}
  \label{fig:population-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/population_density/population_denisty_with_routes_map.png}
  \caption{Superposición de densidad de población y red de rutas de colectivo.}
  \label{fig:population-routes-map}
\end{figure}

El primer mapa destaca las zonas de mayor concentración poblacional, mientras que
la superposición con las rutas permite identificar corredores bien servidos frente
a “manchas” densas con menor cobertura.

El script \texttt{population\_density\_analysis.py} genera gráficos que resumen
esta relación:

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/population_density/coverage_by_density_category.png}
  \caption{Cobertura de transporte por categoría de densidad poblacional.}
  \label{fig:population-coverage}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/population_density/transit_vs_population_scatter.png}
  \caption{Relación entre densidad poblacional y longitud de rutas cercanas.}
  \label{fig:population-scatter}
\end{figure}

En conjunto, los mapas y gráficos muestran que las zonas céntricas concentran
tanto mayor densidad poblacional como mejor cobertura de transporte, mientras que
algunas áreas densas en la periferia aparecen con niveles de servicio más
limitados, sugiriendo posibles oportunidades de mejora.

\subsection{Accesibilidad local a estadios}

Los estadios y arenas deportivas se modelan como puntos de interés dentro del
área de estudio. La tabla \texttt{football\_stadiums} se puebla con coordenadas
de BC Place, Rogers Arena y Pacific Coliseum, y se analizan las paradas y rutas
de colectivo dentro de un radio de 600~m (consistente en todo el trabajo).
Las vistas \texttt{qgis\_stadiums} y \texttt{qgis\_stadium\_proximity} alimentan
los mapas y gráficos de esta sección.

La tabla de estadios y una vista básica de proximidad pueden definirse como:

\begin{lstlisting}[language=SQL]
CREATE TABLE IF NOT EXISTS football_stadiums (
  id serial PRIMARY KEY,
  name text NOT NULL,
  team text,
  latitude float,
  longitude float,
  geom geometry(Point, 4326)
);

CREATE MATERIALIZED VIEW qgis_stadium_proximity AS
SELECT 
  s.name AS stadium_name,
  s.team,
  st.stop_id,
  st.stop_name,
  ST_DistanceSphere(s.geom, st.stop_loc::geometry) AS distance_m,
  st.stop_loc::geometry AS geom
FROM football_stadiums s
JOIN stops st 
  ON ST_DistanceSphere(s.geom, st.stop_loc::geometry) <= 600;
\end{lstlisting}

En el proyecto, \texttt{static\_analysis/queries/sql/08\_stadium\_proximity.sql}
contiene una versión extendida de esta consulta, y el script
\texttt{stadium\_proximity\_analysis.py} utiliza la vista materializada
correspondiente para generar los gráficos.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/stadium_proximity/stadium_map.png}
  \caption{Mapa de estadios y red de paradas y rutas en un radio de 600~m.}
  \label{fig:stadium-map}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/stadium_proximity/stadium_stops_and_routes.png}
  \caption{Paradas y rutas que sirven a cada estadio dentro de 600~m.}
  \label{fig:stadium-stops}
\end{figure}

El mapa muestra que BC Place y Rogers Arena se encuentran en un nodo concentrado
de paradas y rutas de colectivo, mientras que otros recintos presentan menor
densidad de servicio en su entorno inmediato.

El script \texttt{stadium\_proximity\_analysis.py} complementa la lectura
espacial con un gráfico de oferta diaria:

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/stadium_proximity/stadium_trips_per_day.png}
  \caption{Viajes diarios que pasan cerca de cada estadio (radio de 600~m).}
  \label{fig:stadium-trips}
\end{figure}

En este gráfico se observa que los estadios céntricos reciben significativamente
más viajes diarios que aquellos ubicados en zonas residenciales o periféricas.

\subsection{Conectividad entre estadios y áreas de alta densidad}

Finalmente se analiza cómo los estadios se conectan con las zonas de mayor
densidad poblacional. La consulta \texttt{12\_stadium\_population\_overlay.sql}
construye la vista \texttt{qgis\_stadium\_population\_overlay}, que mide cuántas
áreas densas alcanza cada estadio, cuánta población queda conectada y qué tan
intensa es la red de segmentos que realiza esa conexión. La consulta
\texttt{13\_stadium\_density\_connecting\_routes.sql} devuelve las rutas completas
que vinculan estadios con áreas de alta densidad, usadas como capa en QGIS.

Un fragmento representativo de la agregación de conectividad por estadio es:

\begin{lstlisting}[language=SQL]
WITH stadium_connectivity_stats AS (
  SELECT 
    s.id AS stadium_id,
    s.name AS stadium_name,
    s.team,
    s.geom AS stadium_geom,
    COUNT(DISTINCT stc.density_area_id) AS num_high_density_areas_connected,
    COALESCE(SUM(stc.population), 0) AS total_population_connected,
    COALESCE(SUM(rs.total_route_segments), 0) AS total_connecting_segments,
    COALESCE(SUM(rs.total_route_length_km), 0) AS total_route_length_km
  FROM football_stadiums s
  LEFT JOIN stadium_to_density_connectivity stc 
    ON s.id = stc.stadium_id
  LEFT JOIN route_statistics rs 
    ON stc.route_id = rs.route_id
  GROUP BY s.id, s.name, s.team, s.geom
)
CREATE MATERIALIZED VIEW qgis_stadium_population_overlay AS
SELECT
  stadium_name,
  team,
  num_high_density_areas_connected,
  total_population_connected,
  total_connecting_segments,
  total_route_length_km,
  stadium_geom AS geom
FROM stadium_connectivity_stats;
\end{lstlisting}

De forma análoga, \texttt{13\_stadium\_density\_connecting\_routes.sql} agrupa
todos los segmentos de cada ruta conectora usando \texttt{ST\_Collect} para
obtener una geometría de recorrido completa que luego se utiliza en QGIS.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../static_analysis/queries/results/stadium_population/stadium_high_density_population_routes.png}
  \caption{Rutas de colectivo que conectan estadios con áreas de alta densidad poblacional.}
  \label{fig:stadium-density-routes}
\end{figure}

En el mapa se observan claramente los corredores que vinculan los estadios con
las “manchas” de mayor densidad, permitiendo evaluar si la red ofrece conexiones
directas o si la accesibilidad depende de transbordos complejos.

El script \texttt{stadium\_population\_analysis.py} genera gráficos que resumen
estas métricas a nivel agregado:

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/stadium_population/stadium_connectivity_vs_population.png}
  \caption{Relación entre población conectada y segmentos de tránsito conectores por estadio.}
  \label{fig:stadium-connectivity-vs-pop}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../static_analysis/queries/results/stadium_population/stadium_connected_population.png}
  \caption{Población en áreas densas conectadas a cada estadio.}
  \label{fig:stadium-connected-pop}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.9\textwidth]{%
    ../static_analysis/queries/results/stadium_population/stadium_connectivity_metrics.png}
  \caption{Comparación de áreas densas conectadas y segmentos de tránsito por estadio.}
  \label{fig:stadium-connectivity-metrics}
\end{figure}

Los gráficos muestran, por un lado, qué estadios logran conectar a mayor población
en áreas de alta densidad y, por otro, cuán intensa es la infraestructura de
transporte que sostiene esas conexiones. En conjunto con el mapa de rutas
conectoras, permiten identificar estadios con buena cobertura hacia las zonas más
densas de la ciudad frente a otros cuya accesibilidad depende de unos pocos
recorridos.

\section{Análisis con GTFS-Realtime}

Los análisis sobre datos en tiempo real se basan en las trayectorias \emph{map-matched}
almacenadas en \texttt{realtime\_trips\_mdb}, las cuales se comparan con sus equivalentes
programados en \texttt{scheduled\_trips\_mdb}.

\subsection{Velocidad real vs.\ velocidad programada}

La comparación de velocidades se realiza mediante la vista materializada
\texttt{realtime\_speed\_comparison}, que calcula las velocidades programadas
y observadas para cada segmento. Un esquema simplificado de la consulta es:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_speed_comparison;
CREATE MATERIALIZED VIEW realtime_speed_comparison AS
WITH with_next_stop AS (
    SELECT
        d.trip_instance_id,
        d.trip_id,
        d.route_id,
        d.service_date,
        d.stop_sequence,
        d.stop_id,
        d.actual_arrival,
        LEAD(d.stop_sequence) OVER w AS next_stop_sequence,
        LEAD(d.stop_id) OVER w AS next_stop_id,
        LEAD(d.actual_arrival) OVER w AS next_actual_arrival
    FROM rt_trip_updates_deduped d
    WINDOW w AS (PARTITION BY d.trip_instance_id ORDER BY d.stop_sequence)
)
SELECT
    w.trip_instance_id,
    w.trip_id,
    r.route_short_name,
    w.route_id,
    rs.seg_length AS segment_length_m,
    EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) AS scheduled_seconds,
    EXTRACT(EPOCH FROM (w.next_actual_arrival - w.actual_arrival)) AS actual_seconds,
    (rs.seg_length / NULLIF(EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)), 0) * 3.6) AS scheduled_speed_kmh,
    (rs.seg_length / NULLIF(EXTRACT(EPOCH FROM (w.next_actual_arrival - w.actual_arrival)), 0) * 3.6) AS actual_speed_kmh
FROM with_next_stop w
JOIN route_segments rs
    ON rs.trip_id = w.trip_id
    AND rs.stop1_sequence = w.stop_sequence
LEFT JOIN routes r ON r.route_id = w.route_id
WHERE w.next_actual_arrival IS NOT NULL
  AND rs.seg_length > 10
  AND EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) > 0
  AND EXTRACT(EPOCH FROM (w.next_actual_arrival - w.actual_arrival)) > 0;
\end{lstlisting}

A partir de esta vista se generan tanto
mapas como gráficos:

\begin{itemize}
  \item un mapa de diferencia de velocidad que resume espacialmente qué tramos
        son sistemáticamente más lentos o más rápidos que lo previsto,
  \item histogramas y gráficos por ruta y por hora que cuantifican estas
        diferencias.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../realtime_analysis/queries/results/speed_vs_schedule/speed_difference_map.png}
  \caption{Mapa de diferencia de velocidad real vs.\ programada
  (rojo = más lento que lo programado, verde $\approx$ en línea con lo programado,
  amarillo = más rápido).}
  \label{fig:realtime-speed-diff-map}
\end{figure}

En este mapa se identifican rápidamente corredores donde los buses circulan
de forma sistemáticamente más lenta que lo previsto (en rojo), así como tramos
que tienden a adelantarse sobre el horario (en amarillo).

A nivel agregado, se utilizan gráficos para resumir la distribución de estas
diferencias:

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.9\textwidth]{%
    ../realtime_analysis/queries/results/speed_vs_schedule/speed_difference.png}
  \caption{Distribución de la diferencia de velocidad (real $-$ programada).}
  \label{fig:realtime-speed-diff}
\end{figure}

El histograma de diferencias muestra una distribución aproximadamente unimodal,
con una masa importante de segmentos con velocidades similares a las previstas y
colas que capturan tanto episodios de fuerte sobreejecución como segmentos
marcadamente más lentos que el plan.

\subsection{Desempeño de horarios (schedule times)}

La comparación de horarios programados vs.\ observados se realiza mediante la vista
materializada \texttt{realtime\_schedule\_times}, que registra para cada parada la
hora prevista y la hora efectivamente observada. Un fragmento representativo es:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_schedule_times;
CREATE MATERIALIZED VIEW realtime_schedule_times AS
SELECT
    d.trip_instance_id,
    d.trip_id,
    r.route_short_name,
    r.route_long_name,
    d.route_id,
    d.service_date,
    d.stop_sequence,
    d.stop_id,
    s.stop_name,
    ts.arrival_time AS scheduled_arrival_interval,
    d.actual_arrival,
    d.actual_departure,
    d.arrival_delay_seconds,
    d.departure_delay_seconds,
    d.arrival_delay_seconds / 60.0 AS delay_minutes,
    EXTRACT(hour FROM d.actual_arrival) AS hour_of_day,
    EXTRACT(dow FROM d.actual_arrival) AS day_of_week,
    CASE 
        WHEN EXTRACT(dow FROM d.actual_arrival) IN (0, 6) THEN 'Weekend'
        ELSE 'Weekday'
    END AS day_type
FROM rt_trip_updates_deduped d
JOIN routes r ON r.route_id = d.route_id
LEFT JOIN stops s ON s.stop_id = d.stop_id
LEFT JOIN transit_stops ts 
    ON ts.trip_id = d.trip_id 
    AND ts.stop_sequence = d.stop_sequence
WHERE d.arrival_delay_seconds IS NOT NULL;
\end{lstlisting}

A partir de esta vista se construye
un mapa de puntualidad y varios gráficos agregados.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.8\textwidth]{%
    ../realtime_analysis/queries/results/schedule_times/delay_map.png}
  \caption{Mapa de desempeño horario
  (amarillo = adelantado $\geq$ 3~min, verde = dentro de $\pm$3~min,
  rojo = retrasado $\geq$ 3~min).}
  \label{fig:realtime-delay-map}
\end{figure}

El mapa permite ubicar espacialmente los puntos donde el sistema opera de forma
mayormente puntual (en verde) frente a corredores donde predominan los retrasos
o adelantos marcados.

A nivel estadístico, se analizan las distribuciones de demora y su variación por
hora y por ruta:

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/schedule_times/delay_histogram.png}
  \caption{Distribución de demoras respecto al horario programado.}
  \label{fig:realtime-delay-hist}
\end{figure}

Estos gráficos muestran una cola hacia valores positivos que indica predominio
de demoras por encima del horario programado, especialmente en horas pico y en
determinadas rutas troncales.

\subsection{Segmentos de demora y patrones de congestión}

El análisis de demoras por segmento se basa en la vista materializada
\texttt{realtime\_delay\_analysis}, que compara para cada tramo entre paradas
el tiempo programado con el tiempo efectivamente observado. La estructura básica
de la vista es:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_delay_analysis;
CREATE MATERIALIZED VIEW realtime_delay_analysis AS
WITH with_next AS (
    SELECT
        d.trip_instance_id,
        d.trip_id,
        d.route_id,
        d.service_date,
        d.stop_sequence AS from_seq,
        d.stop_id AS from_stop_id,
        d.actual_arrival AS from_arrival,
        d.arrival_delay_seconds AS from_delay,
        LEAD(d.stop_sequence) OVER w AS to_seq,
        LEAD(d.stop_id) OVER w AS to_stop_id,
        LEAD(d.actual_arrival) OVER w AS to_arrival,
        LEAD(d.arrival_delay_seconds) OVER w AS to_delay
    FROM rt_trip_updates_deduped d
    WINDOW w AS (PARTITION BY d.trip_instance_id ORDER BY d.stop_sequence)
)
SELECT
    w.trip_instance_id,
    w.trip_id,
    r.route_short_name,
    w.route_id,
    w.from_seq,
    w.to_seq,
    rs.seg_length AS segment_length_m,
    rs.seg_geom,
    EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) AS scheduled_seconds,
    EXTRACT(EPOCH FROM (w.to_arrival - w.from_arrival)) AS actual_seconds,
    (w.to_delay - w.from_delay) AS segment_delay_change,
    (EXTRACT(EPOCH FROM (w.to_arrival - w.from_arrival)) - 
     EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time))) / 60.0 AS segment_delay_minutes,
    EXTRACT(hour FROM w.from_arrival) AS hour_of_day,
    EXTRACT(dow FROM w.from_arrival) AS day_of_week,
    CASE 
        WHEN EXTRACT(dow FROM w.from_arrival) IN (0, 6) THEN 'Weekend'
        ELSE 'Weekday'
    END AS day_type,
    CASE
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 7 AND 9 THEN 'Morning Rush'
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 16 AND 18 THEN 'Evening Rush'
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 9 AND 16 THEN 'Midday'
        WHEN EXTRACT(hour FROM w.from_arrival) BETWEEN 18 AND 22 THEN 'Evening'
        ELSE 'Night'
    END AS time_period
FROM with_next w
JOIN route_segments rs 
    ON rs.trip_id = w.trip_id 
    AND rs.stop1_sequence = w.from_seq
LEFT JOIN routes r ON r.route_id = w.route_id
WHERE w.to_arrival IS NOT NULL
  AND rs.seg_length > 10
  AND EXTRACT(EPOCH FROM (rs.stop2_arrival_time - rs.stop1_arrival_time)) > 0
  AND EXTRACT(EPOCH FROM (w.to_arrival - w.from_arrival)) > 0;
\end{lstlisting}

A partir de esta vista se generan:

\begin{itemize}
  \item mapas de los “peores” segmentos en términos de demora promedio,
  \item gráficos por hora, tipo de día y severidad de la demora.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/delay_segments/worst_segments.png}
  \caption{Segmentos con mayores demoras promedio.}
  \label{fig:realtime-worst-segments}
\end{figure}

La cartografía de segmentos problemáticos, combinada con gráficos de distribución
por franja horaria, permite identificar cuellos de botella recurrentes donde la
operación se degrada sistemáticamente respecto del plan.

\subsection{Regularidad de headways y \emph{bus bunching}}

El análisis de headways se basa en la vista materializada
\texttt{realtime\_headway\_stats}, que calcula los intervalos entre vehículos
consecutivos en una misma parada y ruta. Un fragmento de la consulta es:

\begin{lstlisting}[language=SQL]
DROP MATERIALIZED VIEW IF EXISTS realtime_headway_stats;
CREATE MATERIALIZED VIEW realtime_headway_stats AS
WITH stop_arrivals AS (
    SELECT
        rtu.route_id,
        r.route_short_name,
        rtu.stop_id,
        s.stop_name,
        rtu.trip_instance_id,
        rtu.trip_id,
        rtu.arrival_time,
        EXTRACT(hour FROM rtu.arrival_time) AS hour_of_day,
        EXTRACT(dow FROM rtu.arrival_time) AS day_of_week,
        CASE 
            WHEN EXTRACT(dow FROM rtu.arrival_time) IN (0, 6) THEN 'Weekend'
            ELSE 'Weekday'
        END AS day_type
    FROM rt_trip_updates rtu
    JOIN routes r ON r.route_id = rtu.route_id
    LEFT JOIN stops s ON s.stop_id = rtu.stop_id
    WHERE rtu.arrival_time IS NOT NULL
      AND rtu.stop_id IS NOT NULL
),
with_prev AS (
    SELECT
        *,
        LAG(arrival_time) OVER (
            PARTITION BY route_id, stop_id
            ORDER BY arrival_time
        ) AS prev_arrival,
        LAG(trip_instance_id) OVER (
            PARTITION BY route_id, stop_id
            ORDER BY arrival_time
        ) AS prev_trip_instance_id
    FROM stop_arrivals
)
SELECT
    route_id,
    route_short_name,
    stop_id,
    stop_name,
    trip_instance_id,
    prev_trip_instance_id,
    arrival_time,
    prev_arrival,
    EXTRACT(EPOCH FROM (arrival_time - prev_arrival)) / 60.0 AS headway_minutes,
    hour_of_day,
    day_of_week,
    day_type
FROM with_prev
WHERE prev_arrival IS NOT NULL
  AND trip_instance_id != prev_trip_instance_id
  AND EXTRACT(EPOCH FROM (arrival_time - prev_arrival)) > 0
  AND EXTRACT(EPOCH FROM (arrival_time - prev_arrival)) < 7200;
\end{lstlisting}

El script \texttt{headway\_analysis.py}
utiliza esta vista para clasificar los intervalos como:

\begin{itemize}
  \item \textbf{Bunched} (\(<3\) minutos): vehículos demasiado próximos.
  \item \textbf{Good} (3--10 minutos): intervalo deseable en rutas frecuentes.
  \item \textbf{Acceptable} (10--20 minutos): servicio menos frecuente pero razonable.
  \item \textbf{Gap} (\(>20\) minutos): esperas prolongadas.
\end{itemize}

La Figura~\ref{fig:realtime-headway-dist} muestra la distribución de headways
obtenida a partir de los registros realtime.

\begin{figure}[H]
  \centering
  \includegraphicsifexists[width=0.75\textwidth]{%
    ../realtime_analysis/queries/results/headway_analysis/headway_distribution.png}
  \caption{Distribución de headways entre vehículos.}
  \label{fig:realtime-headway-dist}
\end{figure}

Otros gráficos (no mostrados aquí) exploran la proporción de headways en cada
categoría por ruta y por periodo del día, permitiendo cuantificar la incidencia
del \emph{bus bunching} y de las brechas de servicio prolongadas.

\section{Discusión y trabajo futuro}

El pipeline desarrollado permite integrar datos GTFS estáticos y GTFS-Realtime en
una única base de datos espacial y reproducir de forma sistemática una serie de
consultas y visualizaciones sobre la red de transporte de Vancouver.
La separación clara entre scripts de ingesta, consultas SQL y scripts de
visualización facilita la extensión del análisis a nuevas ciudades o a períodos
de tiempo adicionales.

Como trabajo futuro se identifican varias líneas de avance: incorporar análisis
de robustez ante fallas (por ejemplo, cierres de estaciones), extender las métricas
de confiabilidad al nivel de pasajero (tiempos puerta a puerta) e integrar datos
de demanda (conteos o validaciones) para estudiar la relación entre oferta,
congestión y ocupación vehicular.

\end{document}


